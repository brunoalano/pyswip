#summary Comparison of PySWIP with different Python/Prolog, inference and constraint packages

= Comparison of PySWIP with Other Prolog and Constraint Systems =

Please don't take these benchmarks too seriously, I don't claim I am an expert in benchmarking, these are just my honest observations; and I am open to your suggestions.

== Constraint Programming ==

We use the classic SEND + MORE = MONEY problem for comparisons, please see [Examples] for a more detailed consideration of the problem.

=== SWI-Prolog vs PySWIP ===

_(sample program deprecated since version 0.1.2)_

[http://www.swi-prolog.org SWI-Prolog] has the clp library for solving integer constraint programming problems. You can use this library to solve constraint programming problems via PySWIP. In this section we try to find out how much overhead PySWIP imposes over calling/querying the _almost_ same prolog code with SW-Prolog.

The following prolog code is used by both SWI-Prolog and PySWIP:
{{{
:- use_module(library('clp/bounds')).

sendmore(Digits) :-
   Digits = [S,E,N,D,M,O,R,Y],
   Digits in 0..9,
   S #\= 0,
   M #\= 0,
   all_different(Digits),
                1000*S + 100*E + 10*N + D
              + 1000*M + 100*O + 10*R + E
   #= 10000*M + 1000*O + 100*N + 10*E + Y,
   label(Digits).
}}}

SWI-Prolog code  has the following line additionaly to start the search:
{{{
:- sendmore(X), write(X), halt.
}}}

PySWIP has the following Python code:
{{{
from pyswip.util import PrologRunner

def main():
    prolog = PrologRunner()
    prolog.query("consult('money.pl')")
    prolog.query("sendmore(X)")

if __name__ == "__main__":
    main()
}}}

We used SWI-Prolog version 5.6.34 (shared library) and PySWIP 0.1.1.

These programs run 5 times and timed using UNIX `time` utility using the following command lines:

For SWI-Prolog:
{{{
$ time pl -q -s sendmoney_pl_benchmark.pl
}}}

For PySWIP:
{{{
$ time python sendmoney_ps_benchmark.py
}}}

Here are the results:
||              || *pure SWI-Prolog* (_sec_) || *PySWIP* (_sec_) || _Result_          ||
|| *Best*       || 0.065                     || 0.095            || PySWIP (0.030 sec) 1.46x slower  ||
|| *Average*    || 0.084                     || 0.102            || PySWIP (0.018 sec) 1.21x slower  ||

Note that, the percentages are very high because this is an easy problem for SWI-Prolog, so the overhead can't be seen clearly. *TODO* Compare them using a harder problem.

=== Python-Constraint vs PySWIP ===

_(sample program deprecated since version 0.1.2)_

[http://labix.org/python-constraint Python-Constraint] is a pure-Python package created by Gustavo Niemeyer for solving constraing programming problems. In this section we compare PySWIP and python-constraint.

We will use the same code in the previous section for PySWIP.

Below is the code for python-constraint:
{{{
from constraint import *

def main():
    problem = Problem()
    problem.addVariables("sendmory", range(10))
    problem.addConstraint(lambda s, e, n, d, m, o, r, y:
                          1000*s+100*e+10*n+d + 1000*m+100*o+10*r+e ==
                          10000*m+1000*o+100*n+10*e+y, "sendmory")
    problem.addConstraint(NotInSetConstraint([0]), "sm")
    problem.addConstraint(AllDifferentConstraint())
    problem.getSolutions()

if __name__ == "__main__":
    main()
}}}

Note that, this is a modified version of the example in python-constraint source; the original code imposed more constraints which resulted in a much faster solution. I have taken out extra constraints to make the code solve the same problem in the previous section (i.e., made it more like the Prolog source).

We used python-constraint 1.1 and PySWIP 0.1.1

The programs run 5 times and timed using UNIX `time` utility using the following command lines:

For python-constraint:
{{{
$ time python sendmoney_pc_benchmark.py
}}}

For PySWIP:
{{{
$ time python sendmoney_ps_benchmark.py
}}}

Here are the results:
||              || *python-constraint* (_sec_) || *PySWIP* (_sec_) || _Result_          ||
|| *Best*       || 52.046                      || 0.095            || python-constraint (51.951 sec) 546.85x slower  ||
|| *Average*    || 52.346                      || 0.102            || python-constraint (52.244 sec) 512.20x slower  ||

PySWIP performs much better than python-constraint since it uses SWI-Prolog to do the search while python-constraint is implemented in pure-Python.

Pros and Cons of PySWIP (compared to python-constraint):
  * (+) Very fast,
  * (+) If you are comfortable in SWI-Prolog/clp, it is easier to write code,
  * (+) If you have already written SWI-Prolog code for your project, it's easier to adapt.
  * (-) Requires writing code in Prolog,
  * (-) Harder to install (requires SWI-Prolog in a shared library),
  * (-) Inflexible

Pros and cons of python-constraint (compared to PySWIP):
  * (+) Pythonic, doesn't require learning Prolog,
  * (+) Flexible,
  * (+) Easy to install (pure-Python package),
  * (-) Very slow,
  * (-) Harder to adapt if you already have prolog code in your project.